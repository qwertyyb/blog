{"id":16,"title":"树结构拖拽的最佳实践","content":"{\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"介绍\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"说到拖拽排序，首先想到的是dnd，即 drag and drop，所以一番搜索后，锁定了两个库。\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://github.com/SortableJS/vue.draggable.next/tree/master\"}}],\"text\":\"vuedraggable\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://github.com/gilnd/vue3-smooth-dnd/tree/main\"}}],\"text\":\"vue3-smooth-dnd\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vuedraggable\"},{\"type\":\"text\",\"text\":\" 之前使用过 vue2 版本的，知根知底，是基于 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Sortable.js\"},{\"type\":\"text\",\"text\":\" 封装的。而 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vue3-smooth-dnd\"},{\"type\":\"text\",\"text\":\" 是基于 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"smooth-dnd\"},{\"type\":\"text\",\"text\":\" 的，从示例上来看非常丝滑。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"需求\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"再来对应一下业务方的需求，业务方的需求是如下图所示的树形的层级结构要支持拖拽调整位置，可以跨层级，上面的两个库都有这样的能力。基于以往的经验，优先选择了 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vuedraggable\"},{\"type\":\"text\",\"text\":\" 来实现。\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/api/v1/file?name=5e7e452005e435f3fc1b84600.png\",\"ratio\":null,\"size\":null,\"align\":\"center\",\"href\":null},\"content\":[{\"type\":\"plain_text\",\"content\":[{\"type\":\"text\",\"text\":\"树形结构图\"}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"库的问题\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vuedraggable\"},{\"type\":\"text\",\"text\":\" 还是比较好用的，基本上能满足条件，但是在引入后，发现有一些交互上的问题难以解决。\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"首先是在拖拽过程中，组件的位置会实时变动。这在某些场景下，比如说单层级场景下，算是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"feature\"},{\"type\":\"text\",\"text\":\"，但是在树状结构中，就有些灾难了，在拖拽过程中，会显得比较乱，给操作者很大的压力，另外就和第二点有关了（此处应有一个动图）。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"跨层级的移动比较难。在把节点从组先的兄弟节点往空的子节点里面拖拽时，会有问题。先来看一下正常的场景，以上面的树形结构图为例，把 @Todo 拖拽到日常知识下，作为日常知识的子节点时，这是没有问题的，非常丝滑。再来看一下空节点的场景，需求是把 @Todo 拖拽到测试内容下，作为测试内容的子节点，此时就搞不定了。这是为什么呢？\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"不管是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vuedraggable\"},{\"type\":\"text\",\"text\":\" 抑或者是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vue-smooth-dnd\"},{\"type\":\"text\",\"text\":\"，对这种树形结构的处理都是一致的，原理上都是两个列表，把数据从一个列表中拖放到另一个列表B中，所以首先就需要列表B在页面中占据位置。以上面的树形结构为参考，在没有子节点的节点中，是没有合适的空间留给空的子节点的，其次树形结构，一般都带有展开和收缩的能力，在收缩的时候，子节点全部收起，这就导致了没有办法往一个没有子节点的节点中插入第一个节点。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"那上面的问题在使用库的前提下，是否方便处理呢？一个比较合适的方案是，在把一个节点A拖拽到另一个节点B上后，释放鼠标后，把节点A作为节点B的最后一个子节点（若节点B没有任何子节点，那就是第一个子节点）。然而库有一个 feature，就是列表的位置会在鼠标拖移时实时变动，这就成了一个灾难。还是以上面的例子为准，使用库没有办法把 “@Todo” 结点拖拽到 测试内容 的节点上，因为当鼠标移入 “测试内容” 节点时，“@Todo” 节点会占据 “测试内容” 节点的位置，而 “测试内容” 节点会被挤到上方或下方，导致完全没有办法实现预期的交互（此处最好有一个动图展示）\"}]}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"自行实现\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在库不满足需求的情景下，就要考虑自行实现了，自行实现也有两个方案，一种是使用鼠标相关的 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"MouseEvent\"},{\"type\":\"text\",\"text\":\"，另一种是使用 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"DragEvent\"},{\"type\":\"text\",\"text\":\" 和 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"DropEvent\"},{\"type\":\"text\",\"text\":\"，而这里我采用的是第三种方案 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"PointerEvent\"},{\"type\":\"text\",\"text\":\"。\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"PointerEvent\"},{\"type\":\"text\",\"text\":\" 可以理解为是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"MouseEvent\"},{\"type\":\"text\",\"text\":\" 和 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"TouchEvent\"},{\"type\":\"text\",\"text\":\" 的升级版，它统一了 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"MouseEvent\"},{\"type\":\"text\",\"text\":\" 和 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"PointerEvent\"},{\"type\":\"text\",\"text\":\"，适配PC端和移动端。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"具体的实现细节，把一个节点的高度分为上中下三部分，根据释放时鼠标的位置，来判断把节点放置在哪个位置，具体如下：\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"/api/v1/file?name=c74816defa53a1914921e1200.png\",\"ratio\":\"946/293\",\"size\":null,\"align\":\"center\",\"href\":null},\"content\":[{\"type\":\"plain_text\",\"content\":[{\"type\":\"text\",\"text\":\"鼠标位置和节点目标位置示意\"}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"这里使用了以下几个功能强大但是可能不太常用的API\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Element.setPointerCapture(event.pointerId)\"},{\"type\":\"text\",\"text\":\": 在鼠标按下时调用，把鼠标事件绑定到元素上，鼠标事件无法在其它元素上触发，后续鼠标事件的 event.target 都会是绑定的元素\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Element.releasePointerCapture(event.pointerId)\"},{\"type\":\"text\",\"text\":\": 在鼠标松开时调用，释放绑定的鼠标\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"document.elementFromPoint(event.clientX, event.clientY)\"},{\"type\":\"text\",\"text\":\": 获取鼠标位置下的元素，由于 event.target 已被绑死，所以可以使用此API获取当前鼠标下的元素\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Element.closest(selector)\"},{\"type\":\"text\",\"text\":\": 递归向上遍历，返回第一个符合 selector 选择器的元素，主要用于和 document.elementFromPoint 结合使用，以获取当前鼠标下的节点元素\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"document.elementsFromPoint(event.clientX, event.clientY)\"},{\"type\":\"text\",\"text\":\": 获取鼠标下的元素数组，元素以事件冒泡的顺序由深入浅返回，使用此API可以替换3、4步骤获取当前鼠标下节点元素\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"HTMLElement.dataset.xxx/data-xxx属性\"},{\"type\":\"text\",\"text\":\": 把节点的一些数据存储在节点 DOM 上，就可以直接通过 DOM 获取节点的数据，比如节点的 id，位置等。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}}]}","path":"/1/12","nextId":17,"createdAt":"2024-02-28T13:11:40.028Z","updatedAt":"2024-09-17T10:40:04.898Z","deleted":false,"deletedAt":null,"attributes":[{"docId":16,"key":"share","value":"48VIcsBN5Yk"}]}