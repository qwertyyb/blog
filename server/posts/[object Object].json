{"id":37,"title":"MacOS 进程间通信 XPC","content":"{\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"缘起\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"缘起于issue: \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://github.com/qwertyyb/Fire/issues/134\"}}],\"text\":\"如何通过命令切换中英文输入状态\"},{\"type\":\"text\",\"text\":\"，想到给业火输入法添加一个命令行功能，通过命令行获取或设置业火输入法当前的输入模式（中文或英文）。由于输入法主程序（后文称之后 MainApp）和 cli 程序必然是两个进程，所以就涉及到跨进程的通信。搜索了一番 MacOS 应用的进程间通信方案，发现了 MacOS 提供了一种称之为 XPC 的进程间通信方案。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"首先需要明确的是，XPC 是一个进程，是一个辅助进程。它有以下几种调用方式：\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"其它进程可以通过相关接口很方便的连接到 XPC 进程，然后就可以在其它进程内像在 XPC 进程内一样很方便的调用 XPC 内的方法，即（MainApp -> XPC)\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在其它进程连接到 XPC 进程后，XPC 就可以进行反向连接，接着从 XPC 进程调用其它进程的方法，即（XPC -> MainApp)\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"通过 XPC 进程，两个进程间可以建立起\"},{\"type\":\"text\",\"marks\":[{\"type\":\"strong\"}],\"text\":\"点对点\"},{\"type\":\"text\",\"text\":\"的跨进程通信，即（MainApp <=> ClientApp）。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC 并不是一个现成可用的进程，需要代码去实现这个进程。之所以会这样，是因为 XPC 虽然是进程间通信的一种方式，但是我理解进程间通信不是 XPC 出现的主要目的。我理解它的主要目的更像是是为了做权限隔离，比如说主进程可以不请求任何权限，而把权限做在 XPC 进程中，这样就把 XPC 的权限和主进和做了隔离。一种常见的应用应该就使用了这种方式，比如在 App Store 下载主程序，但是实际使用时，却需要额外再下载一个 Helper 程序，在 App Store 下载的主程序应该就是 sandboxed 的，有一些权限问题，而 Helper 程序是 XPC 进程，可以不进行沙箱化，这样就把主进程的权限和 Helper 进程做了隔离。因为主进程和 Helper 进程要做权限隔离，又要做通信，所以 XPC 进程有通信的能力。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"添加 XPC 服务\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"可以在 Xcode -> File -> New -> Target -> XPC Service 在项目内添加一个新的 XPC Service Target。添加 XPC Service 会自带 Demo，这个 Demo 在 XPC Service 内添加了一个 performCalculation 方法，用于计算两个数的和，其它进程可以连接到此 XPC 进程调用此方法。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"三种服务类型\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC 进程有三种服务类型，用以处理应对不同的场景，按权限的从小到大分为\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC Service: XPC 进程依附于主进程，主进程退出时，XPC 进程也会退出，主进程间的 XPC 进程是隔离的，也就是说无法在主进程外访问 XPC 进程，这不适用于我们 CLI 的场景，我们是需要让 CLI 进程通过 XPC 进程连接到主进程的。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Launch Agent: 每个登录用户一个进程，以该用户身份运行。如果多个用户使用快速用户切换登录，则每个用户都有自己的运行进程。可以看到这种服务类型下的 XPC 进程已经不依附于主进程了，每个登录用户都只运行一个该进程，符合我们的需求场景。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Launch Daemon: 一个以较高权限级别运行的系统级进程，即\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"root\"},{\"type\":\"text\",\"text\":\"用户进程。Launch Daemon 无法发起与用户进程的连接，但可以响应来自用户的请求。从介绍上来看 Launch Daemon 这种服务类型与进程的通信是单向的，也就是只能响应用户的进程，无法主动发起连接。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Launch Agent 和 Launch Daemon 类型需要特殊的安装和配置。在 macOS 13 之前，应用通常使用安装脚本来配置这些服务类型。在 macOS 13 及更高版本中，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://developer.apple.com/documentation/servicemanagement\"}}],\"text\":\"服务管理\"},{\"type\":\"text\",\"text\":\"框架提供了一种用于打包和安装这些服务类型的新结构。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Launch Agent 安装之后，会在 “系统设置 -> 通用 -> 登录项 -> 允许在后台” 中可以看到此 XPC 服务。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"三种方式\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"MainApp -> XPC\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"主进程（也可以是其它进程）连接到 XPC 进程很简单。代码如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Swift\"},\"content\":[{\"type\":\"text\",\"text\":\"// XPCServiceName 是 XPC Service 的 bundleIdentifier\\nlet connection = NSXPCConnection(serviceName: XPCServiceName)\\n\\n// FireXPCServiceProtocol 是 XPC Service 进程对应的协议\\nconnection.remoteObjectInterface = NSXPCInterface(with: FireXPCServiceProtocol.self)\\nconnection.resume()\\n\\n// remoteObjectProxy 是 XPC Service 进程的协议对象的代理，可以通过此代理像在 XPC Service 内一样调用 XPC 的方法。\\nif let proxy = connection.remoteObjectProxy as? FireXPCServiceProtocol {\\n\\n  // setMainAppEndpoint 是 XPC Service 进程内的方法。\\n  proxy.setMainAppEndpoint(endpoint: self.listener.endpoint) { ret in\\n    NSLog(\\\"[MainAppService] setMainAppEndPoint reply: \\\\(ret)\\\")\\n  }\\n}\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC -> MainApp\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"当主进程链接到 XPC 进程时，主进程就可以调用 XPC 进程的方法，并通过回调获得返回值，这是一种由主进程向 XPC 进程主动发起，XPC 进程向主进程被动回复的通信。但是往往也需要让 XPC 进程主动发起主进程作为被调的场景。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"针对 XPC 作为主调，主进程作为被调用的场景，XPC 也是支持的，主要有以下步骤\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"主进程添加 NSXPCListener 实例以接收来自 XPC 的链接\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"把 1 中 NSXPCListener 实例的 endpoint 传给 XPC 进程，因为要传给 XPC 进程，所以在此之前，是需要先建立起 MainApp -> XPC 进程的连接的。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC 进程接收到 2 中主进程传入的 endpoint，然后使用此 endpoint 作为参数实例化 NSXPCConnection，从而就实现了 XPC -> MainApp 的连接了。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"从上面的步骤可以发现，XPC -> MainApp 的前提是 MainApp -> XPC。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"具体的实现如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"JavaScript\"}},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"MainApp <=> ClientApp\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"从 XPC-> MainApp 这一点出发，就可以很简单的考虑到如何使用 XPC 进程作为中转在 MainApp 和 ClientApp 中建立链接。具体的步骤如下：\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"主进程添加 NSXPCListener 实例以接收来自 XPC 的链接\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"把 1 中 NSXPCListener 实例的 endpoint 传给 XPC 进程，因为要传给 XPC 进程，所以在此之前，是需要先建立起 MainApp -> XPC 进程的连接的。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC 进程接收到 2 中主进程传入的 endpoint，然后把此 endpoint 保存下来，以供 ClientApp 进程获取此 endpoint。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在 ClientApp 进程中，使用 NSPCConnection 和 XPC 进程的 bundleIdentifier 建立起 ClientApp -> XPC 进程的连接。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在 ClientApp 进程中，通过调用 XPC 进程的方法，以获得 3 中在 XPC 进程中保存的 endpoint。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在 ClientApp 进程中，把 5 中获取到的 endpoint 作为参数实例化 NSXPCConnection，使用此实例就可以链接到 MainApp 了，建立起了 ClientApp -> MainApp 的连接。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在建立起了 ClientApp -> MainApp 的连接后，就可以完全抛弃 XPC 进程了，至于 MainApp -> ClientApp 的连接可以参考 XPC -> MainApp，至此就建立起了 MainApp <=> ClientApp 的双向连接。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"具体的实现如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"JavaScript\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"结论\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"XPC 虽然是官方推荐的进程间通信方案，但是更像是一种副作用产品，对于 clientApp <=> MainApp 这种场景，没有开箱即用的方式，针对一个轻量的 clientApp 来说，XPC 未免太重了。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}}]}","path":"/1/12","nextId":38,"createdAt":"2024-09-10T11:12:27.734Z","updatedAt":"2024-09-12T11:41:55.382Z","deleted":false,"deletedAt":null,"attributes":[{"docId":37,"key":"share","value":""}]}