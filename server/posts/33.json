{
  "id": 33,
  "title": "使用 Fetch 实现 SSE 调用",
  "content": "{\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Why Not EventSource\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 最大的问题在于不够灵活，表现在以下方面：\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"鉴权：如果一个接口需要鉴权，那按 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 的文档，有两种鉴权方式，一种是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"withCredentials\"},{\"type\":\"text\",\"text\":\" 把 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Cookie\"},{\"type\":\"text\",\"text\":\" 带到 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Request Headers\"},{\"type\":\"text\",\"text\":\" 中，即 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Cookie\"},{\"type\":\"text\",\"text\":\" 鉴权，另一种是把鉴权参数带在 URL 中，作为 query 参数传给后台由后台取 query 进行鉴权。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 的 method 固定为 Get，无法使用其它的 method。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"出于以上两方面的原因，如果我们要通过 POST 方法在 Header 中传入指定的 Header 进行鉴权的场景下，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 就完全不可用了。下面就来介绍如何使用 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Fetch\"},{\"type\":\"text\",\"text\":\" 实现 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 的能力。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"流式读取返回值\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"fetch 的 response 对象可能用得比较多的是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"response.json\"},{\"type\":\"text\",\"text\":\" 和 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"response.text\"},{\"type\":\"text\",\"text\":\" 方法，用于一次性获取所有返回内容，然而对于 SSE 来说，服务端的返回是流式的，所以这里需要使用 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"response.body\"},{\"type\":\"text\",\"text\":\" 这个对象。\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"response.body\"},{\"type\":\"text\",\"text\":\" 是一个 ReadableStream，可以以流式的方式读取输出。所以简陋版的实现如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"JavaScript\"},\"content\":[{\"type\":\"text\",\"text\":\"const requestSSE = async () => {\\n  const response = await fetch(`https://sse-demo.netlify.app/sse`);\\n  \\n  for await (const chunk of response.body) {\\n      console.log('receive', chunk)\\n  }\\n}\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"输出的每个 chunk 是一个 Uint8Array，这里需要转换为文字，加入文字解码逻辑，代码如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"JavaScript\"},\"content\":[{\"type\":\"text\",\"text\":\"const requestSSE = async () => {\\n  const response = await fetch(`https://sse-demo.netlify.app/sse`);\\n\\n  const decoder = new TextDecoder()\\n  for await (const chunk of response.body) {\\n      console.log('receive', decoder.decode(chunk))\\n  }\\n}\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"查看 ReadableStream 的文档，发现上面的代码可以使用 ReadableStream.pipeThrought 和 TextDecoderStream 进行优化，如下：\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"JavaScript\"},\"content\":[{\"type\":\"text\",\"text\":\"const requestSSE = async () => {\\n  const response = await fetch(`https://sse-demo.netlify.app/sse`);\\n\\n  const decodedStream = response.body.pipeThrough(new TextDecoderStream())\\n  for await (const chunk of decodedStream) {\\n      console.log('receive', chunk)\\n  }\\n}\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"解析返回值\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"通过上面的方式即可拿到每个 chunk，接下来对每个 chunk 按 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"EventSource\"},{\"type\":\"text\",\"text\":\" 的协议进行解析即可拿到每一步的值\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}}]}",
  "path": "/1/12",
  "nextId": 37,
  "createdAt": "2024-08-15T05:03:10.224Z",
  "updatedAt": "2024-09-10T11:12:27.754Z",
  "deleted": false,
  "deletedAt": null,
  "attributes": [
      {
          "docId": 33,
          "key": "share",
          "value": "48VIcsBN5gx"
      }
  ]
}