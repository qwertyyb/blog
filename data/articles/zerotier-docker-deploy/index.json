{"title":"ZeroTier Docker 部署指南","content":"{\"type\":\"doc\",\"content\":[{\"type\":\"toc\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"背景\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"缘起于最近添置了一台小主机，就想部署一个 ZeroTier 以在外网也能访问家里的网络。首选的部署方案当然是 Docker，更优秀的是 ZeroTier 官方也有提供 Docker 镜像，所以我本以为会简单，按照官方的步骤来就可以了，然而事情并不顺利。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"首先明确下需求是在外网环境下能通过这台部署了 ZeroTier 的机器访问所有的内网设备，而不仅仅只是访问部署了 ZeroTier 的设备。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"基础安装\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"首先是根据 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://hub.docker.com/r/zerotier/zerotier\"}}],\"text\":\"官方 Docker 的安装指南\"},{\"type\":\"text\",\"text\":\" ,运行如下的命令运行 ZeroTier 容器。\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Shell\"},\"content\":[{\"type\":\"text\",\"text\":\"docker run --name myzerotier --rm --cap-add NET_ADMIN --device /dev/net/tun zerotier/zerotier:latest abcdefdeadbeef00\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"需要注意的有以下几点：\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"命令行中最后的是 ZeroTier 的网络 ID，需要根据实际情况修改\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在 ZeroTier 官方网站的 Docker 安装中有写，还需要添加 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"—cap-add SYS_ADMIN\"},{\"type\":\"text\",\"text\":\" 参数，所以如果上面的命令不能正常的运行，可以添加这个参数试试。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"可以添加 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"—network host\"},{\"type\":\"text\",\"text\":\" 直接共享主机网络。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"运行上面的命令后，需要去到 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://my.zerotier.com/\"}}],\"text\":\"ZeroTier 的管理台\"},{\"type\":\"text\",\"text\":\"，在对应的网络管理台中，就可以看到对应的设备了。给对应的设备授权后，就会分配 IP 了。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"假设这个网络的 IP 段是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"10.147.20.*\"},{\"type\":\"text\",\"text\":\", 新添加的设备 B 的家庭内网 IP 是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"192.168.1.30\"},{\"type\":\"text\",\"text\":\" 在 ZeroTier 上分配的 IP 是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"10.147.20.100\"},{\"type\":\"text\",\"text\":\"，在此已经有另外一台设备 A （假设 IP 是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"10.147.20.80\"},{\"type\":\"text\",\"text\":\"）已经接入了这个网络，那么设备 A 在外网就可以通过 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"10.147.20.100\"},{\"type\":\"text\",\"text\":\" 访问到这台内网的设备 B 上的服务了。接下来，需要在管理台再配置一个路由，让内外网能通过同一个家庭内网 IP 访问，在 ZeroTier 管理的 Advance 部分添加路由，Destination 填写家庭内网 IP 网段（在这个示例中是 192.168.1.0/24），Via 填写在 ZeroTier 上分配的 IP（在这个示例中是 10.147.20.100），如下图：\"}]},{\"type\":\"image\",\"attrs\":{\"src\":\"data/articles/zerotier-docker-deploy/files/1728542903232-add-routes.png\",\"ratio\":\"1376/194\",\"width\":null,\"align\":null,\"href\":null},\"content\":[{\"type\":\"plain_text\",\"content\":[{\"type\":\"text\",\"text\":\"Add Routes\"}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"这样内外网就可以无缝切换了，在内网环境下，直接使用内网路由器的 IP 段 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"192.168.1.30\"},{\"type\":\"text\",\"text\":\" 来访问这台设备，在外网环境下，打开 ZeroTier 应用后，仍然能通过 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"192.168.1.30\"},{\"type\":\"text\",\"text\":\"访问内网设备。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"问题及解决方案\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Docker 重启 Mac 会变\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"按官方的命令创建并启动容器，然而容器每次重启后，都需要在 ZeroTier 管理台重新授权，然后生成新的网段 IP。而之所以会这样，直接原因是因为 Mac 地址变化了，所以管理台就会认为是一个新的设备，也就需要重新授权了。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"刚开始我走错了路，我以为这里的 Mac 地址是容器的 Mac 地址，所以一直在找如何固定容器的 Mac 地址，让 Mac 地址在重启或重建后保持一致。于是我参考了 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://docs.docker.com/reference/compose-file/\"}}],\"text\":\"Docker Compsoe 的文档\"},{\"type\":\"text\",\"text\":\" ，在这个文档中，我找到了 mac_address 字段，但是可惜的是它不生效，官方文档也有补充说明，在 Docker 版本大于等于 2.24.0 且低于 2.25.0 时才会生效。\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"YAML\"},\"content\":[{\"type\":\"text\",\"text\":\"version: '3.8' # Example version\\nservices:\\n  your_service:\\n    image: your_image\\n    mac_address: your_mac_address\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"}},{\"type\":\"blockquote\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"mac_address\"}]},{\"type\":\"blockquote\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Available with Docker Compose version 2.24.0 and later.\"}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"mac_address\"},{\"type\":\"text\",\"text\":\" sets a MAC address for the service container.\"}]},{\"type\":\"blockquote\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"strong\"}],\"text\":\"Note\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Container runtimes might reject this value (ie. Docker Engine >= v25.0). In that case, you should use \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://docs.docker.com/reference/compose-file/services/#mac_address\"}}],\"text\":\"networks.mac_address\"},{\"type\":\"text\",\"text\":\" instead.\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"推荐使用的是 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"networks.mac_address\"},{\"type\":\"text\",\"text\":\"，于是我使用了 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"networks.mac_address\"},{\"type\":\"text\",\"text\":\"，如下所示例，这样一来，容器本身的 Mac 地址是固定了，但是每次重建容器时 ZeroTier 的 Mac 仍然产生了变化，需要重新授权。直到这时，我才意识到思路出现了问题。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"重新梳理后发现了原因，ZeroTier 会生成一个虚拟网卡，管理台上显示的实际是 ZeroTier 生成的虚拟网卡的 Mac 地址，也就是说容器的 Mac 地址和 ZeroTier 使用的 Mac 地址不是同一个。那如何固定 ZeroTier 生成的虚拟网上的 Mac 地址呢？ZeroTier 会在初始化时，初始化这个 Mac 地址，然后写入配置中，再次启动时，就会读取配置，使用配置中的 Mac 地址，这样一来，Mac 地址就固定了。容器中 ZeroTier 的配置路径为 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"/var/lib/zerotier-one\"},{\"type\":\"text\",\"text\":\"，可以使用 Docker 的 Volume 把配置路径挂载到主机路径上，这样一来容器即使重建 Mac 地址也不会变化了，也就无须再重新授权了。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"无法访问内网其它设备\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"经过上面的操作后，发现虽然可以通过 192.168.1.30 来访问安装 ZeroTier 的设备，但是无法访问到其它的内网设备，经过查找并没有在网上找到解决方案。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"因为外网到安装 ZeroTier 这个设备的网络是通的，所以我猜测可能是这个设备访问其它设备的网络有问题，大概可能是防火墙转发的问题。于是我再次去查看了 ZeroTier 的官方文档，终于在 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://docs.zerotier.com/route-between-phys-and-virt\"}}],\"text\":\"这篇文档\"},{\"type\":\"text\",\"text\":\" 中找到了答案，根据这篇文章设备 IP 转发，然后添加对应的 iptables 规则就好了，如下图：\"}]},{\"type\":\"blockquote\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Enable IP forwarding​\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"This can vary depending on linux distribution. Typically:\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Edit \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"/etc/sysctl.conf\"},{\"type\":\"text\",\"text\":\" to uncomment \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"net.ipv4.ip_forward\"},{\"type\":\"text\",\"text\":\". This enables forwarding at boot.\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"To enable it now\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Shell\"},\"content\":[{\"type\":\"text\",\"text\":\"sudo sysctl -w net.ipv4.ip_forward=1\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Configure iptables​\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Assign some shell variables (personalize these)\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Shell\"},\"content\":[{\"type\":\"text\",\"text\":\"PHY_IFACE=eth0; ZT_IFACE=zt7nnig26\\n\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Add rules to iptables\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Shell\"},\"content\":[{\"type\":\"text\",\"text\":\"sudo iptables -t nat -A POSTROUTING -o $PHY_IFACE -j MASQUERADE\\nsudo iptables -A FORWARD -i $PHY_IFACE -o $ZT_IFACE -m state --state RELATED,ESTABLISHED -j ACCEPT\\nsudo iptables -A FORWARD -i $ZT_IFACE -o $PHY_IFACE -j ACCEPT\\n\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"Save iptables rules for next boot\"}]},{\"type\":\"code_block\",\"attrs\":{\"language\":\"Shell\"},\"content\":[{\"type\":\"text\",\"text\":\"sudo apt install iptables-persistent\\nsudo bash -c iptables-save > /etc/iptables/rules.v4\"}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"接下来来探究一下，为什么这样可以呢？\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"首先第一步启用 IP 转发。默认情况下，如果设备收到了不是自身的数据包会丢弃处理，启用 IP 转发后，系统就不会直接把包丢掉，而是进行转发。因为需要在外网环境下要通过内网这台安装了 ZeroTier 的设备去访问其它内网设备，所以我们的请求的目标不是发给 192.168.1.30 这台设备的，需要由这台设备把数据包转发出去。所以必须要启用 IP 转发。\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"其次是添加 iptables 转发规则，一共有三条规则，一条一条来看。\"}]},{\"type\":\"ordered_list\",\"attrs\":{\"order\":1},\"content\":[{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"第一条规则是往 NAT 表的 POSTROUTING 链添加一条规则，把从 eth0 发出数据包的源地址改为 eth0 的IP 和端口号。假设外网设备 A 通过 ZeroTier 访问内网其它设备时，数据包先从 A 发往安装了 ZeroTier 的设备 B，再由 B 转给 C，那数据包的源地址是 A，然后 B 转发出去时，如果不修改源地址，那么 C 处理后回包往源地址上发送时，就会指向 A，但是 A 只能通过 B 来转发，无法直接发给 A，所以 A 就收不到回包。而这条规则，就是修改了数据包的源地址为 B，这样 C 处理完后，就把回包发给 B，这样 B 就能收到回包，就可以再发转发给 A 了。所以这条规则不仅仅是修改了源地址，也在修改前的源地址（IP 和端口号）和修改后的源地址（IP 和端口号）建立起了一个映射，以方便在收到回包时，能够正确的把包转发给修改前的地址。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"第二条规则，是往 FORWARD 链中添加了一条规则，放过从 eth0 发往 ZeroTier 的数据包。这条规则是为了确保回包（之所以是回包，是因为 —state 参数指定的）能够正常的转发给 ZeroTier。\"}]}]},{\"type\":\"list_item\",\"content\":[{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"第三条规则，是往 FORWARD 链中添加了一条规则，放过从 ZeroTier 发往 eth0 的数据包。这条规则是为了确保 ZeroTier 的数据包能够正常的转发出去。\"}]}]}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"剩下的问题就是在 Docker 容器启动时，自动添加这几条规则。\"}]}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"总结\"}]},{\"type\":\"paragraph\",\"attrs\":{\"align\":\"left\"},\"content\":[{\"type\":\"text\",\"text\":\"在大多数的场景下，把 iptables 等同于防火墙，然而 iptables 不仅仅可以用来当作防火墙，NAT 转发也是一个非常常用的功能。\"}]}]}","createdAt":"2024-10-09T11:04:40.372Z","updatedAt":"2024-10-10T07:28:29.894Z"}